<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Basic Networking | Kaizen Dorks</title>
    <meta name="description" content="

You should already have an HTTP echo server in your cluster, which we deployed by creating a Deployment in the previous module. If you don&#39;t, quickly create one ...">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="icon" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" sizes="192x192" href="/icons/favicon-192x192.png">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="theme-color" content="#ffffff">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="alternate" type="application/rss+xml" href="https://kaizendorks.github.io/rss.xml" title="Kaizen Dorks RSS Feed">
    
    <link rel="preload" href="/assets/css/0.styles.5d050517.css" as="style"><link rel="preload" href="/assets/js/app.51834fbc.js" as="script"><link rel="preload" href="/assets/js/8.247014cf.js" as="script"><link rel="preload" href="/assets/js/4.58bda7f2.js" as="script"><link rel="preload" href="/assets/js/6.bcec5d77.js" as="script"><link rel="preload" href="/assets/js/16.54c3dc31.js" as="script"><link rel="preload" href="/assets/js/12.4a26a5d9.js" as="script"><link rel="prefetch" href="/assets/js/1.df001f69.js"><link rel="prefetch" href="/assets/js/10.5f0d0529.js"><link rel="prefetch" href="/assets/js/11.0fe77024.js"><link rel="prefetch" href="/assets/js/13.06889bf8.js"><link rel="prefetch" href="/assets/js/14.65846497.js"><link rel="prefetch" href="/assets/js/15.9031139f.js"><link rel="prefetch" href="/assets/js/17.3f43ca11.js"><link rel="prefetch" href="/assets/js/18.de809f45.js"><link rel="prefetch" href="/assets/js/19.12c9dc31.js"><link rel="prefetch" href="/assets/js/20.2bf64c63.js"><link rel="prefetch" href="/assets/js/21.9ef09179.js"><link rel="prefetch" href="/assets/js/22.b80cd01c.js"><link rel="prefetch" href="/assets/js/23.820e1359.js"><link rel="prefetch" href="/assets/js/24.d71037af.js"><link rel="prefetch" href="/assets/js/25.7f52a9f1.js"><link rel="prefetch" href="/assets/js/26.8fe185d3.js"><link rel="prefetch" href="/assets/js/27.96056a33.js"><link rel="prefetch" href="/assets/js/28.8dd96cb3.js"><link rel="prefetch" href="/assets/js/29.650c5b83.js"><link rel="prefetch" href="/assets/js/30.57e121e1.js"><link rel="prefetch" href="/assets/js/31.ad56927b.js"><link rel="prefetch" href="/assets/js/32.b6abad72.js"><link rel="prefetch" href="/assets/js/33.6553d10b.js"><link rel="prefetch" href="/assets/js/34.1d5f7c94.js"><link rel="prefetch" href="/assets/js/35.251a8b5f.js"><link rel="prefetch" href="/assets/js/36.2be6f6c8.js"><link rel="prefetch" href="/assets/js/37.ea445df9.js"><link rel="prefetch" href="/assets/js/5.a1551c5c.js"><link rel="prefetch" href="/assets/js/7.efacf8bb.js"><link rel="prefetch" href="/assets/js/9.021d0380.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.5d7b866c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5d050517.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout" class="theme-container"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="logo"><a href="/"><img src="/logo_navbar.png" alt="logo"></a></div> <div class="title"><a href="/" class="nav-link home-link">Kaizen Dorks </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/projects/" class="nav-link">Projects</a></li><li class="nav-item"><a href="/tutorials/" class="nav-link router-link-active">Tutorials</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="nav-item"><a href="/members.html" class="nav-link">Members</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <a href="/rss.xml" class="feed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">Kaizen Dorks </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/projects/" class="nav-link">Projects</a></li><li class="mobile-nav-item"><a href="/tutorials/" class="nav-link router-link-active">Tutorials</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="mobile-nav-item"><a href="/members.html" class="nav-link">Members</a></li> <li class="mobile-nav-item"><a href="/rss.xml" class="feed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></li></ul></div></div></div> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/tutorials/" class="sidebar-link">Tutorials by Kaizen Dorks</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Kubernetes for Developers</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tutorials/kubernetes/" class="sidebar-link">Welcome</a></li><li><a href="/tutorials/kubernetes/1-clusters-nodes.html" class="sidebar-link">1. Clusters and Nodes</a></li><li><a href="/tutorials/kubernetes/2-basic-kubernetes-objects.html" class="sidebar-link">2. Basic Kubernetes Objects</a></li><li><a href="/tutorials/kubernetes/3-basic-networking.html" class="active sidebar-link">3. Basic Networking</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tutorials/kubernetes/3-basic-networking.html#the-problem-with-pods" class="sidebar-link">The problem with Pods</a></li><li class="sidebar-sub-header"><a href="/tutorials/kubernetes/3-basic-networking.html#networking-inside-the-cluster" class="sidebar-link">Networking inside the cluster</a></li><li class="sidebar-sub-header"><a href="/tutorials/kubernetes/3-basic-networking.html#networking-outside-the-cluster" class="sidebar-link">Networking outside the cluster</a></li></ul></li></ul></section></li></ul> </aside> <div class="content-wrapper page"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Daniel</span> <span itemprop="address">   in Dublin, Ireland</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-04-03T00:00:00.000Z">
      Fri Apr 03 2020
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-d832e844><a href="/tag/Kubernetes" data-v-d832e844> Kubernetes </a></li><li class="post-tag" data-v-d832e844><a href="/tag/tutorial" data-v-d832e844> tutorial </a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h1 id="basic-networking"><a href="#basic-networking" class="header-anchor">#</a> Basic Networking</h1> <p>You should already have an HTTP echo server in your cluster, which we deployed by creating a <code>Deployment</code> in the <a href="/tutorials/kubernetes/2-basic-kubernetes-objects.html">previous module</a>. If you don't, quickly create one using the shortcut:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>kubectl create deployment echo-minikube --image<span class="token operator">=</span>k8s.gcr.io/echoserver:1.4
</code></pre></div><h2 id="the-problem-with-pods"><a href="#the-problem-with-pods" class="header-anchor">#</a> The problem with Pods</h2> <p>While we were able to test the server in the <a href="/tutorials/kubernetes/2-basic-kubernetes-objects.html">previous module</a>, we came to the conclusion that it <em>felt</em> wrong.</p> <p>Let's make those problems even more obvious by editing the echo server <code>Deployment</code>, increasing the number of replicas from 1 to 2. We can easily do so via the <code>kubectl edit</code> command, which will open the <code>Deployment</code> YAML manifest in a text editor so you can update the replicas parameter:</p> <div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-bash"><code>$ kubectl edit deployment echo-minikube

<span class="token punctuation">..</span>. editor opens. Update the replicas property, save and close

deployment.apps/echo-minikube edited
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">afraid if vi?</p> <p>By default <code>kubectl</code> will open the YAML in the vi editor. You can configure a different one by editing an environment variable, for example use vscode with:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBE_EDITOR</span><span class="token operator">=</span><span class="token string">'code --wait'</span>
</code></pre></div></div> <p>If you now inspect the pods, you will see there are 2 Pods belonging to this deployment:</p> <div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><br></div><pre class="language-bash"><code>$ kubectl get pod
NAME                             READY   STATUS    RESTARTS   AGE
echo-minikube-5486cd5cd5-nxgq2   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          18m
echo-minikube-5486cd5cd5-qlrmx   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          15m
</code></pre></div><p>Of course, each of them has its own different IP (note the IPs you get in your machine are likely to be different to the ones in this example)</p> <div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br></div><pre class="language-bash"><code>$ kubectl get pod --selector<span class="token operator">=</span>app<span class="token operator">=</span>echo-minikube -o <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'{.items[*].status.podIP}'</span>
<span class="token number">172.17</span>.0.5 <span class="token number">172.17</span>.0.6%
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">what is that dark magic?</p> <p>The command above showcases some advanced <code>kubectl</code> functionality:</p> <ul><li>You can pass a selector to the <code>kubectl get pod</code> command (like the label selector we use above).</li> <li>You can also format the output using <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/" target="_blank" rel="noopener noreferrer">JSONPath<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> so you can extract specific fields, like the podIP (if you dont know the structure of the JSON document you can see the full JSON of any Kubernetes object as in <code>kubectl get pod my-pod -o json</code>)</li></ul> <p>You can take this even further and use an a more complex expression with the <code>jsonpath</code> parameter to do some basic formatting. For example, print each Pod in its own line and add labels to the printed fields as in:</p> <div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br></div><pre class="language-bash"><code>$ kubectl get pod --selector<span class="token operator">=</span>app<span class="token operator">=</span>echo-minikube -o <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'{range .items[*]}{&quot;PodName&quot;}={.metadata.name}; {&quot;PodIp&quot;}={.status.podIP}{&quot;<span class="token entity" title="\n">\n</span>&quot;}{end}'</span>
<span class="token assign-left variable">PodName</span><span class="token operator">=</span>echo-minikube-5486cd5cd5-nxgq2<span class="token punctuation">;</span> <span class="token assign-left variable">PodIp</span><span class="token operator">=</span><span class="token number">172.17</span>.0.5
<span class="token assign-left variable">PodName</span><span class="token operator">=</span>echo-minikube-5486cd5cd5-qlrmx<span class="token punctuation">;</span> <span class="token assign-left variable">PodIp</span><span class="token operator">=</span><span class="token number">172.17</span>.0.6
</code></pre></div></div> <p>If you now wanted to send a request to your echo server, to which of the 2 Pods would you send the request?</p> <p>You would need to decide between sending a request to the replica listening at <code>http://172.17.0.5:8080</code> or the one at <code>http://172.17.0.6:8080</code>. This will immediately defeat the purpose of deploying multiple replicas!</p> <p>On top of that, consider what will happen if these IPs change after redeploying the Pods? You would need to keep constantly checking what these IPs are so you can keep communicating with the Pods.</p> <p>There must be a better way!</p> <h2 id="networking-inside-the-cluster"><a href="#networking-inside-the-cluster" class="header-anchor">#</a> Networking inside the cluster</h2> <h3 id="service-objects"><a href="#service-objects" class="header-anchor">#</a> Service objects</h3> <p>To solve the problem described in the earlier section, we need a solution that:</p> <ul><li>provides us with some internal DNS that let us resolve the IPs using a static value like a given name</li> <li>would automatically load balance across multiple Pods.</li></ul> <p>This is exactly the main usage of the Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener noreferrer">Service<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> objects!</p> <p>A standard <code>Service</code>:</p> <ul><li>will provide you with a host name that you can use instead of the Pod IPs</li> <li>will automatically load balance requests across multiple Pods.</li></ul> <p>And how do you define one? Well, you guessed it, with another YAML manifest. For the most basic <code>Service</code> definition you need to provide:</p> <ul><li>a <code>name</code> for the service, which <strong>becomes the host name</strong> by which the service is available</li> <li>a <code>selector</code> that matches the Pods you want to send the requests to</li> <li>a <strong>port mapping</strong> between ports in the service and ports in the Pod’s containers</li></ul> <p>Therefore, we can create a service that exposes the multiple instances of our echo server as follows:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">|</span> kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: echo-service
spec:
  selector:
    app: echo-minikube
  ports:
  - port: <span class="token number">8080</span>
    targetPort: <span class="token number">8080</span>
EOF
</code></pre></div><p>Once the Service object is created, the cluster will:</p> <ul><li>assign a new internal IP to the service</li> <li>update the cluster’s internal DNS so the host echo-service resolves to the IP assigned to the service</li> <li>Reply to requests on the service IP by load balancing them across both of the echo server Pods.</li></ul> <div class="custom-block tip"><p>That means you will be able to send requests to any of the echo server Pods by sending a request to <code>http://echo-service:8080</code>!</p></div> <div class="custom-block warning"><p class="custom-block-title">Requests across namespaces</p> <p>This might get unnoticed since we keep using the default namespace in the tutorial, so all the objects we are creating are in the same namespace. However, its worth knowing that:</p> <ul><li>The <code>Service</code> must always be in <strong>the same namespace</strong> than the <code>Pods</code> it exposes.</li> <li>If the <code>Service</code> you are trying to reach is defined in a different namespace, you can still communicate by adding the Namespace to the host name, as in <code>http://echo-service.{my-namespace}:8080</code>.</li> <li><strong>Network policies</strong> can be defined to restrict the traffic between different <code>Namespaces</code>. By default clusters don’t apply any restrictions!</li></ul></div> <h3 id="testing-a-service"><a href="#testing-a-service" class="header-anchor">#</a> Testing a service</h3> <p>Let’s verify the service is doing as expected and load balances the requests across the 2 Pods of our echo server. Open 3 separated terminals:</p> <ul><li>In the first terminal, stream the logs of the first Pod (note the name of the Pod can be differnet in your local machine, so get it using <code>kubectl get pod</code>)<div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl logs -f echo-minikube-5486cd5cd5-9zq92
</code></pre></div></li> <li>In the second terminal, do the same for the second Pod</li> <li>In the third terminal, deploy a throwaway <code>busybox-curl</code> container and send multiple HTTP GET requests to the <code>http://echo-service:8080 URL</code>.<div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><div class="highlighted"> </div><br></div><pre class="language-bash"><code>$ kubectl run -it --rm --restart<span class="token operator">=</span>Never busybox --image<span class="token operator">=</span>yauritux/busybox-curl <span class="token function">sh</span>
If you dont see a <span class="token builtin class-name">command</span> prompt, try pressing enter.
/ <span class="token function">curl</span> http://echo-service:8080
</code></pre></div></li></ul> <p>Notice how request reach both Pods!
<img src="/assets/img/curl-service.d9dcf6f8.png" alt="Verifying the service load balances using curl"></p> <h2 id="networking-outside-the-cluster"><a href="#networking-outside-the-cluster" class="header-anchor">#</a> Networking outside the cluster</h2> <p>The previous section presented a much easier way of communicating with applications deployed to the cluster. However, it is a method restricted to traffic from within the cluster. If you try to open the URL <code>http://echo-service:8080</code> in your local browser, you won't receive a response!</p> <p>This is because the <code>Service</code> we created is of the default type of service defined by Kubernetes, a <strong>ClusterIP service</strong>. As its name implies, this service receives its own IP which is also internal to the cluster (which you can see if you run ping echo-service inside the busybox container used at the end of the last section).</p> <p>Therefore, the purpose of a <strong>ClusterIP service</strong> is to facilitate the communication between applications hosted in the cluster.</p> <p>That’s also why Kubernetes defines other types of services and objects for different purposes, like allowing traffic from outside the cluster to reach the desired Pods and containers.</p> <h3 id="nodeport-services"><a href="#nodeport-services" class="header-anchor">#</a> NodePort services</h3> <p>Let's begin by exploring how to use a <strong>NodePort service</strong>. These are very frequently used during development and/or debugging, since they are a quick and easy way to expose a service (although not one you want to rely on for production purposes).</p> <p>What a <a href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" target="_blank" rel="noopener noreferrer">NodePort service<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> does is to publish the service in a random port (by default, the range <code>30000-32767</code>, but this is configurable) of every one of the cluster's nodes (Remember, in the case of minikube there is a single Node).</p> <p>Therefore, as long as you are in the same network than the node, you will be able to reach the service. The following diagram shows a simplified view of a NodePort service in a cluster with a single node:</p> <p><img src="/assets/img/nodeport-service.f6bd3383.png" alt="Simplified view of a NodePort service in a cluster with a single node"></p> <p>Let's see how we can create one. As our test application, let's use a <a href="https://www.elastic.co/kibana" target="_blank" rel="noopener noreferrer">Kibana<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> server rather than the echo-server we have used so far. You can easily create a <code>Deployment</code> to host kibana in our cluster using the images publicly available in Docker Hub:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create deployment kibana --image<span class="token operator">=</span>kibana:7.6.1
</code></pre></div><p>The Pods will take a while to initialize since the container image needs to be pulled down from docker hub, but eventually you will see:</p> <div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br></div><pre class="language-bash"><code>$ kubectl get pod
NAME                     READY   STATUS    RESTARTS   AGE
kibana-9d6df8c77-qz6mk   <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3m59s
</code></pre></div><p>Awesome, we have a Kibana server deployed to our cluster! Now let's expose its port <code>5601</code> so we can open it in the browser.</p> <p>We can easily create a <strong>NodePort service</strong> using the <code>kubectl expose</code> command. This saves us from having to manually define the YAML manifest of the Service (Make sure to expose the default kibana port, <code>5601</code>)</p> <div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br></div><pre class="language-bash"><code>$ kubectl expose deployment kibana --port<span class="token operator">=</span><span class="token number">5601</span> --type<span class="token operator">=</span>NodePort
service/kibana exposed
</code></pre></div><p>If you inspect the service, you can see the random port in the 30000-32767 range in which the new NodePort service was exposed (alongside the cluster nodes’ IP):</p> <div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><div class="highlighted"> </div><br></div><pre class="language-bash"><code>$ kubectl get <span class="token function">service</span> kibana
NAME     TYPE       CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE
kibana   NodePort   <span class="token number">10.109</span>.121.219   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>        <span class="token number">5601</span>:30937/TCP   173m
</code></pre></div><p>From the output above, you can see the port in which the service been exposed, <code>30937</code>. Now you just need to combine this with the IP of one of the nodes of the cluster. When using minikube you can get it by running:</p> <div class="language-bash extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br></div><pre class="language-bash"><code>$ minikube <span class="token function">ip</span>
<span class="token number">192.168</span>.64.4
</code></pre></div><p>This means you can now open <code>http://192.168.64.4:30937/</code> in your browser (Note that the exact IP and port is likely to be different in your machine). You should see a very unimpressive message <em>Kibana server is not ready yet</em>, since we never connected kibana to an <a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener noreferrer">elasticsearch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> server!</p> <ul><li>As an exercise, try to deploy an <a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener noreferrer">elasticsearch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> server to the cluster and connect it to your kibana Deployment!</li></ul> <div class="custom-block tip"><p>Since we are using <code>minikube</code>, once a NodePort service is created you can simply use the following command to automatically open it in your browser:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ minikube <span class="token function">service</span> kibana
</code></pre></div></div> <div class="custom-block warning"><p class="custom-block-title">Following online in Katacoda?</p> <p>If you are running in Katacoda, you won't be able to reach out the server returned by the <code>minikube ip</code> command. You also won't be able to open it in the browser using the <code>minikube service kibana</code> command.</p> <p>Don't worry, instead you just need to:</p> <ul><li>get the service port using <code>kubectl get service</code></li> <li>Clicking the <code>+</code> icon at the top of the tabs, then click <em>Select port to view on Host 1</em> from the menu</li> <li>A new browser tab will open. When prompted, enter the service port</li></ul> <p>Alternatively, you can just send a request using <code>curl</code>. From the Katacoda shell run:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> <span class="token variable"><span class="token variable">$(</span>minikube <span class="token function">ip</span><span class="token variable">)</span></span>:31770
</code></pre></div><p>You should get a 503 response with the expected <em>Kibana server is not ready yet</em> message.</p></div> <p><img src="/assets/img/kibana-browser.7264a352.png" alt="Reaching Kibana from our browser"></p> <h3 id="ingress"><a href="#ingress" class="header-anchor">#</a> Ingress</h3> <p>Every time a <strong>NodePort</strong> service is created, a random port is assigned to it. And each different service will get its own port assigned. This makes them great for quickly exposing a service during development/debugging, but not something you want to rely upon for your production workloads.</p> <p>That is why Kubernetes provides another abstraction designing for exposing primarily HTTP/S services outside the cluster, the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener noreferrer">Ingress<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> object. With an Ingress, you can specify a map between a specific host name (like <code>my-service.my-company.io</code>) and a regular Kubernetes service.</p> <div class="custom-block tip"><p>Before we can use an <code>Ingress</code> object with <code>minikube</code>, we need fist to enable the ingress addon:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ minikube addons <span class="token builtin class-name">enable</span> ingress
</code></pre></div><blockquote><p>If you are running in mac, you might need to recreate your minikube environment using <code>minikube start --vm=true</code></p></blockquote></div> <p>Let's see an example. This time we will use a simple web application in our test, so begin by creating a <code>Deployment</code> with:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create deployment webapp --image<span class="token operator">=</span>nginxdemos/hello
</code></pre></div><p>Before we can create an Ingress, we need to create a regular <code>Service</code> like the ones we saw in the <a href="#networking-inside-the-cluster">networking inside the cluster section</a>. The container for this web application is listening on port <code>80</code>, so let's create a service like:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">|</span> kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
spec:
  selector:
    app: webapp
  ports:
  - port: <span class="token number">80</span>
    targetPort: <span class="token number">80</span>
EOF
</code></pre></div><p>Now we have all the pieces in place to create our first <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener noreferrer">Ingress<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> object. We are going to map the host name <code>my-webapp.contoso.io</code> to the service <code>webapp-service</code> we have just created. The service itself maps to the actual container running the web application:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">|</span> kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: webapp-ingress
spec:
  rules:
  - host: my-webapp.contoso.io
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: webapp-service
            port:
              number: <span class="token number">80</span>
EOF
</code></pre></div><div class="custom-block warning"><p>In versions <strong>prior to Kubernetes 1.19</strong>, the Ingress is defined with a different schema. The equivalent would be:</p> <div class="language- extra-class"><pre class="language-text"><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: webapp-ingress
spec:
  rules:
  - host: my-webapp.contoso.io
    http:
      paths:
      - backend:
          serviceName: webapp-service
          servicePort: 80
EOF
</code></pre></div><p>Depending on the version, you might even need to use <code>apiVersion: extensions/v1beta1</code>.</p> <p>Check your Kubernetes version by running <code>kubectl version</code> and look at the server version.</p></div> <p>You might be wondering, how is this going to enable traffic from outside the cluster? That is because in the Kubernetes cluster, we have an <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" target="_blank" rel="noopener noreferrer">Ingress controller<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, that we just deployed when we enabled the minikuke ingress addon.</p> <blockquote><p>Minikube adds the <a href="https://kubernetes.github.io/ingress-nginx/" target="_blank" rel="noopener noreferrer">NGINX Ingress controller<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> when enabling the Ingress addon. If you inspect your cluster, you will see it in the <code>kube-system</code> namespace.</p></blockquote> <p>Let's see how the Ingress controllers work:</p> <ul><li>This controller is deployed to every node of the cluster, and traditionally listens on ports 80/443.</li> <li>A request sent to port 80/443 of any node in the cluster is then handled by the <code>Ingress controller</code>.</li> <li>The controller will inspect the host name in the request (like <code>my-webapp.contoso.io</code> in a request like <code>http://my-webapp.contoso.io</code>), and call the relevant downstream service according to all the <code>Ingress</code> objects that were defined (ie, the <code>webapp-service</code> in our example)</li></ul> <p>The following diagram shows this process taking a simplified view of a cluster with a single node:
<img src="/assets/img/ingress.9f524cee.png" alt="Simplified view of Ingress objects in a cluster with a single node"></p> <p>So all that is left to see our Ingress working is to create a DNS entry that points <code>my-webapp.contoso.io</code> to the IP of your cluster nodes. This is easy in our minikube environment since there is only a single node.</p> <ul><li>Get the node IP using<div class="language-bash extra-class"><pre class="language-bash"><code>$ minikube <span class="token function">ip</span>
<span class="token number">192.168</span>.64.4
</code></pre></div></li> <li>Update the hosts file of your local machine (found in <code>/etc/hosts</code> for Mac/Linux and <code>C:\Windows\System32\Drivers\etc\hosts</code> for Windows). Add a new entry like:<div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">192.168</span>.64.4 my-webapp.contoso.io
</code></pre></div></li></ul> <div class="custom-block tip"><p>In production clusters, this is usually solved with a load balancer that sits in fronts of your nodes. The load balancer also listens on ports 80/443, and balances requests across all the nodes.</p> <p>Therefore, you create DNS entries that map the desired host name with the IP of the <em>load balancer</em>.</p></div> <p>Once you save the modified hosts file, navigate to http://my-webapp.contoso.io in your browser. You should see the sample hello-world website in all its glory!
<img src="/assets/img/ingress-website-in-browser.a2eeeda5.png" alt="Sample website accessed as an Ingress"></p> <div class="custom-block warning"><p class="custom-block-title">Following online in Katacoda?</p> <p>If you are running in Katacoda, you won't be able to map its host file and test your Ingress the same way we did locally.</p> <p>However you can send a request using <code>curl</code> from the Katacoda shell that simulates the change made to the local hosts file. Using the <code>--resolve</code> option we can manually tell curl to map <code>my-webapp.contoso.io</code> to the IP returned by <code>minikube ip</code>:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> --resolve my-webapp.contoso.io:80:<span class="token variable"><span class="token variable">$(</span>minikube <span class="token function">ip</span><span class="token variable">)</span></span> http://my-webapp.contoso.io
</code></pre></div><p>You should see the HTML page printed to the Katacoda shell.</p></div> <p>This concludes the networking basics. Together with the previous modules of the tutorial, you should now have a very strong base! In addition to feeling more comfortable using Kubernetes as a developer, this base should help you learning more advanced topics.</p> <a href="/tutorials/kubernetes/2-basic-kubernetes-objects" class="tutorial-cta-link" data-v-231230e8>
  Prev module
</a></div> <footer><!----> <hr> <!----> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#the-problem-with-pods" title="The problem with Pods">The problem with Pods</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#networking-inside-the-cluster" title="Networking inside the cluster">Networking inside the cluster</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#service-objects" title="Service objects">Service objects</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#testing-a-service" title="Testing a service">Testing a service</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#networking-outside-the-cluster" title="Networking outside the cluster">Networking outside the cluster</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#nodeport-services" title="NodePort services">NodePort services</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#ingress" title="Ingress">Ingress</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940><li class="contact-item" data-v-fdbf4940><a href="https://github.com/kaizendorks" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-fdbf4940><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-fdbf4940></path></svg>
          
        </a></li><li class="contact-item" data-v-fdbf4940><a href="https://www.npmjs.com/~kaizendorks" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-codepen" data-v-fdbf4940><polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2" data-v-fdbf4940></polygon><line x1="12" y1="22" x2="12" y2="15.5" data-v-fdbf4940></line><polyline points="22 8.5 12 15.5 2 8.5" data-v-fdbf4940></polyline><polyline points="2 15.5 12 8.5 22 15.5" data-v-fdbf4940></polyline><line x1="12" y1="2" x2="12" y2="8.5" data-v-fdbf4940></line></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940><li class="copyright-item" data-v-fdbf4940><a href="https://policies.google.com/privacy?hl=en-US" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940>Privacy Policy</a></li><li class="copyright-item" data-v-fdbf4940><a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940>CC BY 4.0 License</a></li><li class="copyright-item" data-v-fdbf4940><a href="/tutorials/kubernetes/.html" class="nav-link" data-v-fdbf4940>Copyright © 2020-present Kaizen Dorks</a></li></ul></div></footer></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.51834fbc.js" defer></script><script src="/assets/js/8.247014cf.js" defer></script><script src="/assets/js/4.58bda7f2.js" defer></script><script src="/assets/js/6.bcec5d77.js" defer></script><script src="/assets/js/16.54c3dc31.js" defer></script><script src="/assets/js/12.4a26a5d9.js" defer></script>
  </body>
</html>
