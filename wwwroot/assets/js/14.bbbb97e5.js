(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{356:function(e,t,s){e.exports=s.p+"assets/img/curl-service.d9dcf6f8.png"},357:function(e,t,s){e.exports=s.p+"assets/img/kibana-browser.7264a352.png"},398:function(e,t,s){"use strict";s.r(t);var a=s(4),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"basic-networking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#basic-networking"}},[e._v("#")]),e._v(" Basic Networking")]),e._v(" "),a("p",[e._v("You should already have an HTTP echo server in your cluster, which we deployed by creating a "),a("code",[e._v("Deployment")]),e._v(" in the "),a("RouterLink",{attrs:{to:"/tutorials/kubernetes/2-basic-kubernetes-objects.html"}},[e._v("previous module")]),e._v(". If you don't, quickly create one using the shortcut:")],1),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("kubectl create deployment echo-minikube --image"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("k8s.gcr.io/echoserver:1.4\n")])])]),a("h2",{attrs:{id:"the-problem-with-pods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-problem-with-pods"}},[e._v("#")]),e._v(" The problem with Pods")]),e._v(" "),a("p",[e._v("While we were able to test the server in the "),a("RouterLink",{attrs:{to:"/tutorials/kubernetes/2-basic-kubernetes-objects.html"}},[e._v("previous module")]),e._v(", we came to the conclusion that it "),a("em",[e._v("felt")]),e._v(" wrong.")],1),e._v(" "),a("p",[e._v("Let's make those problems even more obvious by editing the echo server "),a("code",[e._v("Deployment")]),e._v(", increasing the number of replicas from 1 to 2. We can easily do so via the "),a("code",[e._v("kubectl edit")]),e._v(" command, which will open the "),a("code",[e._v("Deployment")]),e._v(" YAML manifest in a text editor so you can update the replicas parameter:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("br"),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl edit deployment echo-minikube\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(". editor opens. Update the replicas property, save and close\n\ndeployment.apps/echo-minikube edited\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("afraid if vi?")]),e._v(" "),a("p",[e._v("By default "),a("code",[e._v("kubectl")]),e._v(" will open the YAML in the vi editor. You can configure a different one by editing an environment variable, for example use vscode with:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("export")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("KUBE_EDITOR")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'code --wait'")]),e._v("\n")])])])]),e._v(" "),a("p",[e._v("If you now inspect the pods, you will see there are 2 Pods belonging to this deployment:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl get pod\nNAME                             READY   STATUS    RESTARTS   AGE\necho-minikube-5486cd5cd5-nxgq2   "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("/1     Running   "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("          18m\necho-minikube-5486cd5cd5-qlrmx   "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("/1     Running   "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("          15m\n")])])]),a("p",[e._v("Of course, each of them has its own different IP (note the IPs you get in your machine are likely to be different to the ones in this example)")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl get pod --selector"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("app"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("echo-minikube -o "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("jsonpath")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'{.items[*].status.podIP}'")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("172.17")]),e._v(".0.5 "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("172.17")]),e._v(".0.6%\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("what is that dark magic?")]),e._v(" "),a("p",[e._v("The command above showcases some advanced "),a("code",[e._v("kubectl")]),e._v(" functionality:")]),e._v(" "),a("ul",[a("li",[e._v("You can pass a selector to the "),a("code",[e._v("kubectl get pod")]),e._v(" command (like the label selector we use above).")]),e._v(" "),a("li",[e._v("You can also format the output using "),a("a",{attrs:{href:"https://kubernetes.io/docs/reference/kubectl/jsonpath/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JSONPath"),a("OutboundLink")],1),e._v(" so you can extract specific fields, like the podIP (if you dont know the structure of the JSON document you can see the full JSON of any Kubernetes object as in "),a("code",[e._v("kubectl get pod my-pod -o json")]),e._v(")")])]),e._v(" "),a("p",[e._v("You can take this even further and use an a more complex expression with the "),a("code",[e._v("jsonpath")]),e._v(" parameter to do some basic formatting. For example, print each Pod in its own line and add labels to the printed fields as in:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl get pod --selector"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("app"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("echo-minikube -o "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("jsonpath")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'{range .items[*]}{"PodName"}={.metadata.name}; {"PodIp"}={.status.podIP}{"'),a("span",{pre:!0,attrs:{class:"token entity",title:"\\n"}},[e._v("\\n")]),e._v("\"}{end}'")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("PodName")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("echo-minikube-5486cd5cd5-nxgq2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("PodIp")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("172.17")]),e._v(".0.5\n"),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("PodName")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("echo-minikube-5486cd5cd5-qlrmx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("PodIp")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("172.17")]),e._v(".0.6\n")])])])]),e._v(" "),a("p",[e._v("If you now wanted to send a request to your echo server, to which of the 2 Pods would you send the request?")]),e._v(" "),a("p",[e._v("You would need to decide between sending a request to the replica listening at "),a("code",[e._v("http://172.17.0.5:8080")]),e._v(" or the one at "),a("code",[e._v("http://172.17.0.6:8080")]),e._v(". This will immediately defeat the purpose of deploying multiple replicas!")]),e._v(" "),a("p",[e._v("On top of that, consider what will happen if these IPs change after redeploying the Pods? You would need to keep constantly checking what these IPs are so you can keep communicating with the Pods.")]),e._v(" "),a("p",[e._v("There must be a better way!")]),e._v(" "),a("h2",{attrs:{id:"networking-inside-the-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#networking-inside-the-cluster"}},[e._v("#")]),e._v(" Networking inside the cluster")]),e._v(" "),a("h3",{attrs:{id:"service-objects"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-objects"}},[e._v("#")]),e._v(" Service objects")]),e._v(" "),a("p",[e._v("To solve the problem described in the earlier section, we need a solution that:")]),e._v(" "),a("ul",[a("li",[e._v("provides us with some internal DNS that let us resolve the IPs using a static value like a given name")]),e._v(" "),a("li",[e._v("would automatically load balance across multiple Pods.")])]),e._v(" "),a("p",[e._v("This is exactly the main usage of the Kubernetes "),a("a",{attrs:{href:"https://kubernetes.io/docs/concepts/services-networking/service/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Service"),a("OutboundLink")],1),e._v(" objects!")]),e._v(" "),a("p",[e._v("A standard "),a("code",[e._v("Service")]),e._v(":")]),e._v(" "),a("ul",[a("li",[e._v("will provide you with a host name that you can use instead of the Pod IPs")]),e._v(" "),a("li",[e._v("will automatically load balance requests across multiple Pods.")])]),e._v(" "),a("p",[e._v("And how do you define one? Well, you guessed it, with another YAML manifest. For the most basic "),a("code",[e._v("Service")]),e._v(" definition you need to provide:")]),e._v(" "),a("ul",[a("li",[e._v("a "),a("code",[e._v("name")]),e._v(" for the service, which "),a("strong",[e._v("becomes the host name")]),e._v(" by which the service is available")]),e._v(" "),a("li",[e._v("a "),a("code",[e._v("selector")]),e._v(" that matches the Pods you want to send the requests to")]),e._v(" "),a("li",[e._v("a "),a("strong",[e._v("port mapping")]),e._v(" between ports in the service and ports in the Pod’s containers")])]),e._v(" "),a("p",[e._v("Therefore, we can create a service that exposes the multiple instances of our echo server as follows:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("cat")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v("EOF "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: echo-service\nspec:\n  selector:\n    app: echo-minikube\n  ports:\n  - port: "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("8080")]),e._v("\n    targetPort: "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("8080")]),e._v("\nEOF\n")])])]),a("p",[e._v("Once the Service object is created, the cluster will:")]),e._v(" "),a("ul",[a("li",[e._v("assign a new internal IP to the service")]),e._v(" "),a("li",[e._v("update the cluster’s internal DNS so the host echo-service resolves to the IP assigned to the service")]),e._v(" "),a("li",[e._v("Reply to requests on the service IP by load balancing them across both of the echo server Pods.")])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[e._v("That means you will be able to send requests to any of the echo server Pods by sending a request to "),a("code",[e._v("http://echo-service:8080")]),e._v("!")])]),e._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("Requests across namespaces")]),e._v(" "),a("p",[e._v("This might get unnoticed since we keep using the default namespace in the tutorial, so all the objects we are creating are in the same namespace. However, its worth knowing that:")]),e._v(" "),a("ul",[a("li",[e._v("The "),a("code",[e._v("Service")]),e._v(" must always be in "),a("strong",[e._v("the same namespace")]),e._v(" than the "),a("code",[e._v("Pods")]),e._v(" it exposes.")]),e._v(" "),a("li",[e._v("If the "),a("code",[e._v("Service")]),e._v(" you are trying to reach is defined in a different namespace, you can still communicate by adding the Namespace to the host name, as in "),a("code",[e._v("http://echo-service.{my-namespace}:8080")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("Network policies")]),e._v(" can be defined to restrict the traffic between different "),a("code",[e._v("Namespaces")]),e._v(". By default clusters don’t apply any restrictions!")])])]),e._v(" "),a("h3",{attrs:{id:"testing-a-service"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#testing-a-service"}},[e._v("#")]),e._v(" Testing a service")]),e._v(" "),a("p",[e._v("Let’s verify the service is doing as expected and load balances the requests across the 2 Pods of our echo server. Open 3 separated terminals:")]),e._v(" "),a("ul",[a("li",[e._v("In the first terminal, stream the logs of the first Pod (note the name of the Pod can be differnet in your local machine, so get it using "),a("code",[e._v("kubectl get pod")]),e._v(")"),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl logs -f echo-minikube-5486cd5cd5-9zq92\n")])])])]),e._v(" "),a("li",[e._v("In the second terminal, do the same for the second Pod")]),e._v(" "),a("li",[e._v("In the third terminal, deploy a throwaway "),a("code",[e._v("busybox-curl")]),e._v(" container and send multiple HTTP GET requests to the "),a("code",[e._v("http://echo-service:8080 URL")]),e._v("."),a("div",{staticClass:"language-bash extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br")]),a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl run -it --rm --restart"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("Never busybox --image"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("yauritux/busybox-curl "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sh")]),e._v("\nIf you dont see a "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("command")]),e._v(" prompt, try pressing enter.\n/ "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("curl")]),e._v(" http://echo-service:8080\n")])])])])]),e._v(" "),a("p",[e._v("Notice how request reach both Pods!\n"),a("img",{attrs:{src:s(356),alt:"Verifying the service load balances using curl"}})]),e._v(" "),a("h2",{attrs:{id:"networking-outside-the-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#networking-outside-the-cluster"}},[e._v("#")]),e._v(" Networking outside the cluster")]),e._v(" "),a("p",[e._v("The previous section presented a much easier way of communicating with applications deployed to the cluster. However, it is a method restricted to traffic from within the cluster. If you try to open the URL "),a("code",[e._v("http://echo-service:8080")]),e._v(" in your local browser, you won't receive a response!")]),e._v(" "),a("p",[e._v("This is because the "),a("code",[e._v("Service")]),e._v(" we created is of the default type of service defined by Kubernetes, a "),a("strong",[e._v("ClusterIP service")]),e._v(". As its name implies, this service receives its own IP which is also internal to the cluster (which you can see if you run ping echo-service inside the busybox container used at the end of the last section).")]),e._v(" "),a("p",[e._v("Therefore, the purpose of a "),a("strong",[e._v("ClusterIP service")]),e._v(" is to facilitate the communication between applications hosted in the cluster.")]),e._v(" "),a("p",[e._v("That’s why Kubernetes defines other types of services for different purposes, like allowing traffic from outside the cluster to reach the desired Pods and containers. In this section we are goin to explore how to use a "),a("strong",[e._v("NodePort service")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"nodeport-services"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodeport-services"}},[e._v("#")]),e._v(" NodePort services")]),e._v(" "),a("p",[e._v("What a "),a("a",{attrs:{href:"https://kubernetes.io/docs/concepts/services-networking/service/#nodeport",target:"_blank",rel:"noopener noreferrer"}},[e._v("NodePort service"),a("OutboundLink")],1),e._v(" does is to publish the service in a random port (by default, the range "),a("code",[e._v("30000-32767")]),e._v(", but this is configurable) of every one of the cluster's nodes (Remember, in the case of minikube there is a single Node).")]),e._v(" "),a("p",[e._v("Therefore, as long as you are in the same network than the node, you will be able to reach the service.")]),e._v(" "),a("p",[e._v("For this section, let's use a different example than the echo server we have used so far. Let's use a "),a("a",{attrs:{href:"https://www.elastic.co/kibana",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kibana"),a("OutboundLink")],1),e._v(" server instead!. You can easily create a "),a("code",[e._v("Deployment")]),e._v(" to host kibana in our cluster using the images publicly available in Docker Hub:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ kubectl create deployment kibana --image=kibana:7.6.1\n")])])]),a("p",[e._v("The Pods will take a while to initialize since the container image needs to be pulled down from docker hub, but eventually you will see:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl get pod\nNAME                     READY   STATUS    RESTARTS   AGE\nkibana-9d6df8c77-qz6mk   "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("/1     Running   "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("          3m59s\n")])])]),a("p",[e._v("Awesome, we have a Kibana server deployed to our cluster! So, how can reach its default port (5601) from our browser?")]),e._v(" "),a("p",[e._v("We can easily create a "),a("strong",[e._v("NodePort service")]),e._v(" using the "),a("code",[e._v("kubectl expose")]),e._v(" command. This saves us from having to manually define the YAML manifest of the Service (Make sure to expose the default kibana port, "),a("code",[e._v("5601")]),e._v(")")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl expose deployment kibana --port"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("5601")]),e._v(" --type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("NodePort\nservice/kibana exposed\n")])])]),a("p",[e._v("If you inspect the service, you can see the random port in the 30000-32767 range in which the new NodePort service was exposed (alongside the cluster nodes’ IP):")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br")]),a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ kubectl get "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("service")]),e._v(" kibana\nNAME     TYPE       CLUSTER-IP       EXTERNAL-IP   PORT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("S"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("          AGE\nkibana   NodePort   "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10.109")]),e._v(".121.219   "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("5601")]),e._v(":30937/TCP   173m\n")])])]),a("p",[e._v("This means you can now open "),a("code",[e._v("http://192.168.64.4:30937/")]),e._v(" in your browser (Note that the exact IP and port is likely to be different in your machine). You should see a very unimpressive Kibana server is not ready yet message, since we never connected kibana to an "),a("a",{attrs:{href:"https://www.elastic.co/products/elasticsearch",target:"_blank",rel:"noopener noreferrer"}},[e._v("elasticsearch"),a("OutboundLink")],1),e._v(" server!")]),e._v(" "),a("p",[a("img",{attrs:{src:s(357),alt:"Reaching Kibana from our browser"}})]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[e._v("Since we are using "),a("code",[e._v("minikube")]),e._v(", once a NodePort service is created you can simply use the following command to automatically open it in your browser:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ minikube "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("service")]),e._v(" kibana\n")])])])]),e._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("Following online in Katacoda?")]),e._v(" "),a("p",[e._v("You won’t be able to access the exposed service in your browser. However, you will still be able to create the service and verify it works from outside the cluster!")]),e._v(" "),a("p",[e._v("Once you find out the port assigned to the service (for example, 31770) run the following command in the Katacoda shell:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("curl")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[a("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$(")]),e._v("minikube "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("ip")]),a("span",{pre:!0,attrs:{class:"token variable"}},[e._v(")")])]),e._v(":31770\n")])])]),a("p",[e._v("You should get a 503 response with the expected Kibana server is not ready yet message.")])]),e._v(" "),a("p",[e._v("And this finishes the overview on the basic Kuberntes networking features. As an exercise, try to deploy an "),a("a",{attrs:{href:"https://www.elastic.co/products/elasticsearch",target:"_blank",rel:"noopener noreferrer"}},[e._v("elasticsearch"),a("OutboundLink")],1),e._v(" server to the cluster and connect it to your kibana Deployment!")])])}),[],!1,null,null,null);t.default=r.exports}}]);